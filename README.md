# Visual DJ Analysis Studio 🎵

Die Vision: Das Visual DJ Analysis Studio
Unser Ziel ist es nicht, Musik zu verwalten. Unser Ziel ist es, Musik sichtbar zu machen.
Für DJs und Musikproduzenten ist eine Musikbibliothek mehr als nur eine Sammlung von Dateien. Sie ist eine Palette von Emotionen, Energien und Texturen. Doch bisher waren wir gezwungen, diese Palette im Dunkeln zu durchsuchen, uns auf unser Gedächtnis und simple Zahlen wie BPM und Tonart zu verlassen. Das Visual DJ Analysis Studio beendet dieses Ratespiel.
Wir verwandeln abstrakte Daten in eine visuelle, intuitive Landkarte deiner Musik.
Stell dir vor, du könntest den Herzschlag eines Tracks auf einen Blick erfassen. Unsere fortschrittliche Analyse-Engine, die auf einem soliden Fundament aus bewährter Audio-Technologie wie Librosa aufbaut, schaut tiefer als jedes andere Tool. Sie extrahiert nicht nur die grundlegenden Metadaten, sondern malt ein detailliertes Bild von jedem einzelnen Song:
Die Energie-Kurve: Wir zeigen dir den dynamischen Verlauf eines Tracks als visuellen Graphen. Du siehst sofort, wo das Intro aufbaut, wo der Drop einschlägt und wo das Outro ausklingt. Kein blindes Vorhören mehr – du siehst die Struktur.
Die Klangfarbe: Von warmen, dunklen Bässen bis zu kristallklaren Hi-Hats – unsere Analyse visualisiert die "Helligkeit" und Textur deiner Tracks und gibt dir eine neue Ebene der klanglichen Organisation.
Die Emotion: Basierend auf diesen tiefen Einblicken weisen wir deinen Tracks nachvollziehbare, regelbasierte Stimmungs-Tags zu – von "treibend" und "euphorisch" bis hin zu "düster" und "melancholisch".
Der "Creator Studio": Dein Pult für das perfekte Set
Das Herzstück unserer Vision ist der Creator Studio. Hier wird die Analyse zur Kunst. Anstatt Playlists mühsam zusammenzusuchen, malst du dein Set:
Du zeichnest auf einer leeren Leinwand den gewünschten Energieverlauf deines Abends. Ein langsamer Aufbau? Ein explosiver Peak zur Primetime, gefolgt von einem sanftem Ausklang? Du definierst die Reise.
Unsere intelligente Playlist-Engine wird zu deinem persönlichen Musik-Kurator. Sie durchsucht deine visuell aufbereitete Bibliothek und findet genau die Tracks, deren eigener "Herzschlag" perfekt zu dem von dir gezeichneten Spannungsbogen passt. Sie respektiert dabei die Regeln des harmonischen Mixens und sorgt für nahtlose BPM-Übergänge.
Das Ergebnis ist keine zufällige Liste von Songs. Es ist ein maßgeschneidertes, dramaturgisch perfektes DJ-Set, das deine kreative Vision widerspiegelt – generiert in Minuten, nicht in Stunden.
Zuverlässigkeit und Kontrolle im Kern
Wir wissen, dass Kreativität ein stabiles Fundament braucht. Deshalb ist unser System von Grund auf auf Zuverlässigkeit ausgelegt. Die Analyseergebnisse sind konsistent und reproduzierbar. Du hast die volle Kontrolle über die Parameter und kannst dich darauf verlassen, dass die Daten, mit denen du arbeitest, korrekt sind. Die Bibliothek, die du einmal aufbaust, wird zu deinem verlässlichsten Werkzeug.
Das Visual DJ Analysis Studio ist mehr als ein Tool. Es ist ein neues Paradigma für die Musikorganisation. Es gibt dir die Superkraft, deine Musik nicht nur zu hören, sondern sie zu sehen, zu verstehen und auf eine völlig neue Art und Weise zu gestalten.

[![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)](https://python.org)
[![React](https://img.shields.io/badge/React-18+-61DAFB.svg)](https://reactjs.org)
[![FastAPI](https://img.shields.io/badge/FastAPI-Latest-009688.svg)](https://fastapi.tiangolo.com)
[![TypeScript](https://img.shields.io/badge/TypeScript-4.9+-3178C6.svg)](https://typescriptlang.org)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

## 🚀 Features

### 🎵 Musik sichtbar machen: Tiefgehende Audio-Analyse

Unsere fortschrittliche Analyse-Engine, basierend auf bewährter Audio-Technologie wie Librosa (und optional Essentia), extrahiert nicht nur grundlegende Metadaten, sondern malt ein detailliertes Bild von jedem einzelnen Song:

-   **Energie-Kurve**: Visualisierung des dynamischen Verlaufs eines Tracks als Graph. Erfasse auf einen Blick, wo das Intro aufbaut, der Drop einschlägt und das Outro ausklingt.
-   **Klangfarbe (Timbre)**: Analyse und Visualisierung der "Helligkeit" und Textur deiner Tracks, von warmen Bässen bis zu kristallklaren Hi-Hats.
-   **Emotion & Stimmung**: Regelbasierte Stimmungs-Tags (z.B. "treibend", "euphorisch", "düster", "melancholisch") basierend auf tiefen Einblicken in die Audio-Eigenschaften.
-   **BPM-Erkennung**: Präzise Tempo-Analyse.
-   **Key-Detection**: Automatische Tonart-Erkennung und Camelot Wheel Mapping.
-   **Batch-Processing**: Parallele Verarbeitung großer Musikbibliotheken für schnelle Ergebnisse.

### 🎨 Creator Studio: Dein Pult für das perfekte Set

Das Herzstück unserer Vision. Hier wird die Analyse zur Kunst. Anstatt Playlists mühsam zusammenzusuchen, malst du dein Set:

-   **Intuitives Energie-Design**: Zeichne auf einer leeren Leinwand den gewünschten Energieverlauf deines Abends. Definiere die dramaturgische Reise deines Sets.
-   **Intelligente Playlist-Engine**: Unser persönlicher Musik-Kurator durchsucht deine visuell aufbereitete Bibliothek und findet Tracks, deren "Herzschlag" perfekt zu deinem gezeichneten Spannungsbogen passt.
-   **Harmonisches Mixing**: Berücksichtigung von Camelot Wheel-basierten Übergängen für nahtlose Mixe.
-   **BPM Transition**: Sanfte Tempo-Übergänge für einen fließenden Mix.
-   **Mood Progression**: Stimmungs-kohärente Abfolgen für eine emotionale Reise.
-   **Custom Presets**: Benutzerdefinierte Sortier- und Auswahl-Algorithmen für maximale Kontrolle.

### 📊 Professional Features & Zuverlässigkeit

-   **Real-time Updates**: WebSocket-basierte Live-Überwachung des Analysefortschritts.
-   **Export-Funktionen**: Playlists als M3U, JSON, CSV, Rekordbox-kompatibel.
-   **Advanced Caching**: Multi-Level Cache für optimale Performance und schnelle wiederholte Analysen.
-   **Responsive UI**: Modernes React-Interface für eine intuitive Benutzererfahrung auf allen Geräten.
-   **API-First**: Robuste RESTful API mit automatischer Dokumentation für einfache Integrationen.
-   **Konsistente Analyse**: Analyseergebnisse sind konsistent und reproduzierbar, für volle Kontrolle und Verlässlichkeit.

## 🏗️ Architektur

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   React Frontend│◄──►│   FastAPI       │◄──►│   Core Engine   │
│   - Dashboard   │    │   - REST API    │    │   - Audio       │
│   - Library     │    │   - WebSocket   │    │   - Playlist    │
│   - Creator     │    │   - Validation  │    │   - Mood        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                       ┌─────────────────┐
                       │  Data Management│
                       │  - SQLite DB    │
                       │  - Cache System │
                       │  - File Manager │
                       └─────────────────┘
```

## 🛠️ Installation

### Systemanforderungen
- **Python**: 3.8 oder höher
- **Node.js**: 16.0 oder höher
- **RAM**: Mindestens 4GB (8GB empfohlen)
- **Speicher**: 2GB für Cache und Datenbank

### Installation

1. **Repository klonen**
   ```bash
   git clone [repository-url]
   cd Audio_Analyse_tool
   ```

2. **Entwicklungsumgebung starten (Windows)**
   ```bash
   start-dev.bat
   ```

3. **Entwicklungsumgebung starten (Linux/Mac)**
   ```bash
   chmod +x start-dev.sh
   ./start-dev.sh
   ```

4. **Manueller Start** (falls gewünscht)
   ```bash
   # Root-Abhängigkeiten installieren
   npm install
   
   # Frontend-Abhängigkeiten installieren
   cd src && npm install && cd ..
   
   # Backend-Abhängigkeiten installieren
   pip install -r requirements.txt
   
   # Services starten
   npm run monorepo:dev
   ```

## 📁 Projektstruktur

```
Audio_Analyse_tool/
├── backend/                    # Python Backend
│   ├── main.py                # FastAPI Hauptanwendung
│   ├── api/                   # API Layer
│   │   ├── endpoints/         # REST Endpoints
│   │   └── models.py          # Pydantic Models
│   ├── core_engine/           # Business Logic
│   │   ├── audio_analysis/    # Audio-Analyse Engine
│   │   ├── playlist_engine/   # Playlist-Generierung
│   │   ├── mood_classifier/   # Stimmungsklassifikation
│   │   ├── data_management/   # Datenmanagement
│   │   └── export/            # Export-Funktionen
│   └── config/                # Konfiguration
├── src/                       # React Frontend
│   ├── components/            # UI Komponenten
│   ├── pages/                 # Hauptseiten
│   ├── hooks/                 # Custom React Hooks
│   ├── types/                 # TypeScript Definitionen
│   └── utils/                 # Hilfsfunktionen
├── data/                      # Daten & Cache
├── config/                    # Globale Konfiguration
├── tests/                     # Test Suite
├── SYSTEM_DOKUMENTATION.md   # Vollständige Systemdokumentation
├── ARCHITEKTUR_OVERVIEW.md    # Technische Architektur
└── README.md                  # Diese Datei
```

## 🌐 Zugriff

- **Frontend**: http://localhost:3000
- **Backend**: http://localhost:8000
- **API-Dokumentation**: http://localhost:8000/docs

## 🔧 Konfiguration

### Umgebungsvariablen

Kopiere `.env.example` zu `.env` und passe die Werte an:

```bash
cp .env.example .env
```

Wichtige Einstellungen:
- `DEBUG=true` - Debug-Modus aktivieren
- `PORT=8000` - Backend-Port
- `REACT_APP_API_URL=http://localhost:8000` - API-URL für Frontend
- `MAX_FILE_SIZE_MB=500` - Maximale Dateigröße für Uploads

### Essentia Audioanalyse

> ⚠️ **Wichtig**: Essentia kann unter Windows schwer zu installieren sein.

**Option 1: Librosa Fallback (Standard)**
- Keine zusätzliche Installation erforderlich
- Verwendet Librosa als Fallback
- Funktioniert sofort nach Setup

**Option 2: Essentia installieren (optional)**
```bash
# Versuch 1: Standard-Installation
pip install essentia

# Versuch 2: TensorFlow-Variante
pip install essentia-tensorflow

# Versuch 3: Kompilieren aus Quellcode
# Siehe: https://essentia.upf.edu/installing.html
```

**Essentia aktivieren:**
In `.env` setzen:
```
ESSENTIA_ENABLED=true
```

## 🧪 Tests

### Alle Tests ausführen
```bash
# Backend-Tests
pytest tests/ -v

# Frontend-Tests
cd src && npm test

# Integration-Tests
npm run test:integration
```

### Test-Setup prüfen
```bash
# Grundlegende Setup-Validierung
python tests/unit/test_basic_setup.py
```

## 🛠️ Verfügbare Skripte

| Skript | Beschreibung |
|--------|--------------|
| `npm run monorepo:dev` | Startet Backend und Frontend |
| `npm run start:backend` | Startet nur das Backend |
| `npm run start:frontend` | Startet nur das Frontend |
| `npm run build` | Build für beide Services |
| `npm run test` | Führt alle Tests aus |
| `npm run lint` | Code-Qualität prüfen |
| `npm run clean` | Temporäre Dateien löschen |

## 🐛 Bekannte Probleme & Lösungen

### 1. Essentia-Installation fehlschlägt
- **Problem**: `pip install essentia` schlägt fehl
- **Lösung**: Verwende Librosa-Fallback (funktioniert automatisch)
- **Alternative**: Siehe Essentia-Dokumentation für manuelle Installation

### 2. Ports bereits belegt
- **Problem**: Port 8000 oder 3000 bereits in Verwendung
- **Lösung**: Ports in `.env` ändern
  ```
  PORT=8001
  PORT=3001
  ```

### 3. ImportError: No module named 'backend'
- **Problem**: Python-Pfad nicht korrekt
- **Lösung**: Im Root-Verzeichnis ausführen, PYTHONPATH ist korrekt konfiguriert

### 4. Frontend startet nicht
- **Problem**: `npm run monorepo:dev` fehlschlägt
- **Lösung**: 
  1. `npm install` im Root-Verzeichnis
  2. `npm install` im `src/` Verzeichnis
  3. Erneut versuchen

## 📖 Dokumentation

- **[📋 Systemdokumentation](SYSTEM_DOKUMENTATION.md)** - Vollständige Dokumentation aller Komponenten
- **[🏗️ Architektur-Overview](ARCHITEKTUR_OVERVIEW.md)** - Technische Architektur und Design-Patterns
- **[🔧 API-Dokumentation](http://localhost:8000/docs)** - Interaktive API-Docs (nach Start)
- **[🧪 Testing-Guide](tests/README.md)** - Test-Strategien und -Ausführung

## 🎯 Verwendung

### 1. Audio-Analyse starten

```python
# Via API
POST /api/analysis/start
{
    "scan_paths": ["/path/to/music"],
    "file_formats": [".mp3", ".wav", ".flac"],
    "enable_multiprocessing": true
}
```

### 2. Playlist generieren

```python
# Via API
POST /api/playlists/generate
{
    "preset_name": "DJ Set - Harmonic Flow",
    "target_length_minutes": 60,
    "seed_tracks": ["track1.mp3"],
    "rules": {
        "bpm_tolerance": 5,
        "key_compatibility": true,
        "energy_flow": "build"
    }
}
```

### 3. Frontend-Integration

```typescript
// React Hook für Track-Daten
const { data: tracks, isLoading } = useTracksQuery({
    bpm_min: 120,
    bpm_max: 130,
    mood: 'euphoric',
    sort_by: 'energy'
});

// Playlist-Generierung
const generatePlaylist = useMutation({
    mutationFn: (params) => playlistAPI.generate(params),
    onSuccess: (playlist) => {
        console.log('Playlist erstellt:', playlist.name);
    }
});
```

## 📊 Performance

### Benchmark-Ergebnisse

| Metrik | Wert | Beschreibung |
|--------|------|-------------|
| **Analyse-Geschwindigkeit** | ~2-5 Tracks/Sekunde | Abhängig von CPU und Dateigröße |
| **Cache-Hit-Rate** | >90% | Bei wiederholten Analysen |
| **Memory-Usage** | <500MB | Pro Worker-Prozess |
| **Playlist-Generierung** | <2 Sekunden | Für 100 Tracks |
| **API-Response-Time** | <100ms | Für Standard-Queries |

### Unterstützte Audio-Formate
- **Standard**: MP3, WAV, FLAC, AAC, OGG, M4A
- **Erweitert**: AIFF, AU, WMA, MP4, 3GP, AMR, OPUS, WebM, MKV

## 🎯 Entwicklung

### Code-Style
- **Backend**: PEP 8 (Python)
- **Frontend**: ESLint + Prettier (JavaScript/React)

### Debugging
- **Backend**: `DEBUG=true` in `.env`
- **Frontend**: Browser DevTools
- **Logs**: `./data/logs/` Verzeichnis

## 📄 Lizenz

MIT License - siehe [LICENSE](LICENSE) Datei.

## 🤝 Beitrag

1. Fork erstellen
2. Feature-Branch erstellen (`git checkout -b feature/AmazingFeature`)
3. Commits erstellen (`git commit -m 'Add some AmazingFeature'`)
4. Push (`git push origin feature/AmazingFeature`)
5. Pull Request erstellen

## 📞 Support

Bei Problemen:
1. Prüfe die [bekannten Probleme](#-bekannte-probleme--lösungen)
2. Starte mit `start-dev.bat` (Windows) oder `start-dev.sh` (Linux/Mac)
3. Prüfe die Logs im Terminal
4. Erstelle ein Issue mit System-Informationen
